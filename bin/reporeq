#!/usr/bin/env bash
# reporeq - The simplest and last package manager you will ever use
# Usage: ./reporeq [requirements-file]

set -euo pipefail

# Parse a line into url and ref
# Usage: parse_line "https://github.com/user/repo@v1.0.0"
# Sets: PARSE_URL, PARSE_REF
parse_line() {
    local line="$1"
    PARSE_URL="$line"
    PARSE_REF=""

    # Handle SSH URLs (git@host:path) - split only on @ after the path
    if [[ "$line" =~ ^git@[^:]+: ]]; then
        # SSH URL: git@host:org/repo[@ref]
        local path_part="${line#*:}"
        if [[ "$path_part" == *@* ]]; then
            PARSE_REF="${path_part##*@}"
            PARSE_URL="${line%@*}"
        fi
        return
    fi

    # Handle HTTP(S) URLs - may contain user:pass@host
    if [[ "$line" =~ ^https?:// ]]; then
        # Strip protocol to find path
        local without_proto="${line#*://}"
        # Find path after host (first /)
        if [[ "$without_proto" == */* ]]; then
            local path_part="${without_proto#*/}"
            # Look for @ only in path part (after first /)
            if [[ "$path_part" == *@* ]]; then
                PARSE_REF="${path_part##*@}"
                PARSE_URL="${line%@*}"
            fi
        fi
        return
    fi

    # Fallback for other URL schemes
    if [[ "$line" == *@* ]]; then
        PARSE_URL="${line%@*}"
        PARSE_REF="${line##*@}"
        # Reset if ref contains colon (likely part of URL)
        if [[ "$PARSE_REF" == *:* ]]; then
            PARSE_URL="$line"
            PARSE_REF=""
        fi
    fi
}

# Allow sourcing for testing
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    return 0
fi

readonly REQUIREMENTS_FILE="${1:-reporeq.txt}"
readonly INSTALL_DIR=".reporeq"

if [[ ! -f "$REQUIREMENTS_FILE" ]]; then
    echo "Error: Requirements file '$REQUIREMENTS_FILE' not found" >&2
    exit 1
fi

TEMP_DIR="$(mktemp -d -p .)"
readonly TEMP_DIR

mkdir -p "$TEMP_DIR/bin"

while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%$'\r'}"
    [[ -z "$line" || "$line" == \#* ]] && continue

    parse_line "$line"
    url="$PARSE_URL"
    ref="$PARSE_REF"

    repo_name="$(basename "$url" .git)"
    dest="$TEMP_DIR/$repo_name"

    # Clean up existing symlinks pointing to this repo (overlay support)
    for link in "$TEMP_DIR/bin"/*; do
        if [[ -L "$link" ]]; then
            target="$(readlink "$link")"
            if [[ "$target" == "../$repo_name/"* ]]; then
                rm -f "$link"
            fi
        fi
    done 2>/dev/null || true

    rm -rf "$dest"

    if [[ -z "$ref" ]]; then
        echo ":: $repo_name @ HEAD"
        if ! git clone --quiet --depth 1 "$url" "$dest"; then
            echo "Error: Failed to clone $url" >&2
            rm -rf "$TEMP_DIR"
            exit 1
        fi
    else
        echo ":: $repo_name @ $ref"
        if ! git clone --quiet "$url" "$dest"; then
            echo "Error: Failed to clone $url" >&2
            rm -rf "$TEMP_DIR"
            exit 1
        fi
        if ! git -C "$dest" checkout --quiet "$ref"; then
            echo "Error: Failed to checkout $ref for $repo_name" >&2
            rm -rf "$TEMP_DIR"
            exit 1
        fi
    fi

    if [[ -d "$dest/bin" ]]; then
        for exe in "$dest/bin"/*; do
            if [[ -x "$exe" && -f "$exe" ]]; then
                ln -sf "../$repo_name/bin/$(basename "$exe")" "$TEMP_DIR/bin/$(basename "$exe")"
            fi
        done
    fi
done < "$REQUIREMENTS_FILE"

rm -rf "$INSTALL_DIR"
mv "$TEMP_DIR" "$INSTALL_DIR"

echo ":: Done. PATH: export PATH=\"\$PWD/$INSTALL_DIR/bin:\$PATH\""
